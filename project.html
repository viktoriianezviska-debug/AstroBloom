<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AstroBloom — Premium Interactive Globe (Full Page)</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;700&display=swap" rel="stylesheet">

  <!-- Chart.js (for NDVI chart) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <!-- Three.js + Globe.gl -->
  <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
  <script src="https://unpkg.com/globe.gl"></script>

  <!-- Styling - minimal, dark, elegant -->
  <style>
    /* Basic page layout */
    :root{
      --accent: #ff1493;
      --muted: #9ca3af;
      --panel-bg: rgba(5,6,10,0.85);
      --glass-border: rgba(255,20,147,0.08);
      --card-bg: #0b0b0e;
      --text: #e6e6e9;
      --success: #22c55e;
    }

    html,body{
      height:100%;
      margin:0;
      background: #000;
      color:var(--text);
      font-family: 'Syne', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow: hidden;
    }

    /* Full-screen two-column layout */
    .app {
      display: grid;
      grid-template-columns: 1fr 440px;
      height:100vh;
      width:100vw;
      gap: 20px;
      align-items: stretch;
      padding: 18px;
      box-sizing: border-box;
    }

    /* Left - globe container: full bleed globe */
    .globe-wrap{
      position:relative;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 8px 40px rgba(0,0,0,0.7);
      background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(3,3,3,0.9));
    }

    /* globe canvas holder (globe.gl will append a canvas inside) */
    #globeViz {
      width:100%;
      height:100%;
      background: transparent; /* keep space black -> no earth background image */
      display:block;
    }

    /* Right - UI panel */
    .panel {
      position:relative;
      padding: 18px;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(8,8,10,0.9), rgba(7,7,9,0.92));
      box-shadow: 0 12px 40px rgba(17,0,40,0.45);
      border: 1px solid var(--glass-border);
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0; /* for overflow handling */
    }

    .panel .title {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    .panel h1 { font-size:20px; margin:0; color:var(--accent); letter-spacing:0.2px; }
    .panel p.lead { color:var(--muted); margin:0; font-size:13px; }

    /* Controls block */
    .controls {
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .row {
      display:flex;
      gap:10px;
      align-items:center;
    }

    .btn {
      background: linear-gradient(180deg,#16161a,#0f0f11);
      color:var(--text);
      border:1px solid rgba(255,255,255,0.03);
      padding:8px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .btn.ghost {
      background:transparent;
      border:1px dashed rgba(255,255,255,0.04);
      color:var(--muted);
      font-weight:500;
    }
    .btn.accent {
      background: linear-gradient(90deg,var(--accent), #ff66b3);
      color: white;
      border: none;
      box-shadow: 0 6px 18px rgba(255,20,147,0.12);
    }
    .btn.disabled { opacity:0.5; pointer-events:none; }

    /* Month slider & display */
    .slider-row {
      display:flex;
      gap:12px;
      align-items:center;
      width:100%;
    }
    input[type="range"]{
      -webkit-appearance:none;
      background: linear-gradient(90deg, rgba(255,20,147,0.18), rgba(255,20,147,0.06));
      height:6px;
      border-radius:999px;
      outline:none;
      flex:1;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:18px;
      height:18px;
      border-radius:50%;
      background:var(--accent);
      box-shadow: 0 6px 18px rgba(255,20,147,0.18);
      border:2px solid rgba(255,255,255,0.08);
    }

    /* Country buttons grid */
    .countries {
      display:grid;
      grid-template-columns: repeat(2,1fr);
      gap:8px;
    }
    .country-btn {
      background: linear-gradient(180deg,#0b0b0e,#0c0c0f);
      border-radius:10px;
      padding:8px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      cursor:pointer;
      border:1px solid rgba(255,255,255,0.02);
      color:var(--text);
      font-weight:600;
      font-size:13px;
    }
    .country-btn:hover { transform:translateY(-2px); box-shadow: 0 8px 20px rgba(0,0,0,0.5); }

    /* Chart card */
    .card {
      margin-top:6px;
      background: linear-gradient(180deg,#060607,#0a0a0c);
      border-radius:12px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.02);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .chart-wrap { height:210px; width:100%; }

    /* AI panel */
    .ai-box {
      background: linear-gradient(180deg,#070809,#0b0b0e);
      border-radius:10px;
      padding:10px;
      color:var(--muted);
      font-size:13px;
      min-height:64px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .ai-row { display:flex; gap:8px; align-items:center; }

    /* Tooltip on globe (custom) */
    #tooltip {
      position: absolute;
      pointer-events:none;
      background: rgba(15,15,20,0.92);
      color: #fff;
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      border: 1px solid rgba(255,20,147,0.06);
      transform: translate(-50%, -150%);
      white-space:nowrap;
      z-index: 80;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
      display:none;
    }

    /* Responsive adjustments */
    @media (max-width:1100px){
      .app { grid-template-columns: 1fr 380px; gap:12px; padding:12px; }
      .panel { width:100%; height:calc(100vh - 48px); overflow:auto; }
    }
    @media (max-width:820px){
      /* stack vertically on small screens */
      .app { grid-template-columns: 1fr; grid-template-rows: 1fr 520px; gap:10px; padding:10px; }
      .panel { width:100%; height:520px; overflow:auto; }
    }

    /* tiny helper styles for small labels */
    .small { font-size:12px; color:var(--muted); }
    .muted { color:var(--muted); }

    /* end of styles */
  </style>
</head>
<body>
  <!-- App container -->
  <div class="app">

    <!-- Left: Globe -->
    <div class="globe-wrap" id="globeWrap">
      <!-- globe will be inserted into this div -->
      <div id="globeViz"></div>

      <!-- tooltip for hover on globe -->
      <div id="tooltip" role="status" aria-hidden="true"></div>
    </div>

    <!-- Right: Control panel -->
    <div class="panel" role="region" aria-label="Controls">
      <div class="title">
        <div>
          <h1>AstroBloom — Pulse & NDVI</h1>
          <p class="lead">Dynamic blooms that pulse with NDVI intensity. Hover points for species info. Click countries to zoom.</p>
        </div>
        <div style="text-align:right;">
          <div class="small muted">Local demo</div>
          <div style="font-weight:700; color:var(--muted); font-size:13px;">v1 · demo</div>
        </div>
      </div>

      <!-- Controls -->
      <div class="controls" aria-hidden="false">

        <!-- slider + play -->
        <div class="row slider-row" role="group" aria-label="Month controls">
          <div class="small muted">Month:</div>
          <div style="min-width:70px; font-weight:700; color:var(--accent);" id="monthLabel">January</div>
          <input id="monthSlider" type="range" min="0" max="11" step="1" value="0" aria-label="Month slider" />
          <button id="playBtn" class="btn accent" aria-pressed="false" title="Play animation">▶ Play</button>
        </div>

        <!-- countries -->
        <div>
          <div class="small muted">Countries</div>
          <div class="countries" id="countryList" role="list" style="margin-top:8px;"></div>
        </div>

        <!-- Chart card -->
        <div class="card" style="margin-top:6px;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:700; color:var(--accent);">NDVI Trend & Forecast</div>
            <div class="small muted">5yr + 1yr forecast</div>
          </div>
          <div class="chart-wrap">
            <canvas id="ndviChart" aria-label="NDVI chart" role="img"></canvas>
          </div>

          <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
            <div class="small muted">Click a data point to select month</div>
            <div style="flex:1"></div>
            <button id="predictBtn" class="btn ghost" title="Get AI prediction for selected month">Get AI Prediction</button>
          </div>
        </div>

        <!-- AI box -->
        <div class="ai-box" id="aiBox">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:700; color:var(--accent);">AI Prediction</div>
            <div class="small muted">Quick explanation</div>
          </div>
          <div id="aiText" style="color:var(--muted); font-size:13px;">Select a month on the NDVI chart then click "Get AI Prediction".</div>
        </div>

        <!-- upload / utils -->
        <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
          <label style="font-size:13px; color:var(--muted);">Upload MODIS HDF:</label>
          <input id="hdfInput" type="file" accept=".hdf,.HDF" />
          <div id="uploadMsg" class="small muted" style="margin-left:auto;"></div>
        </div>

        <div id="footerNote" class="small muted" style="margin-top:6px;">
          This demo uses simulated NDVI & synthetic bloom points for UI preview only.
        </div>

      </div>
    </div>

  </div>

  <!-- Full script: data generation, globe, chart, interactions -->
  <script>
  /* ============================
     AstroBloom — Full Page Script
     Features:
       - Globe (no background image) in black space
       - Color-coded bloom points by location/species
       - Points pulse with NDVI-derived intensity
       - Hover tooltip showing species + peak month + intensity
       - Click country to zoom and update chart
       - Slider + play/pause to animate months
       - NDVI chart with historical + predicted values
       - Simple AI prediction simulation
       - File upload simulation (HDF)
     ============================ */

  // --- Utility helpers -----------------------------------------------------

  // Hex to HSL converter (returns {h,s,l})
  function hexToHSL(hex) {
    // strip #
    hex = hex.replace('#','');
    if(hex.length === 3){
      hex = hex.split('').map(c => c+c).join('');
    }
    const r = parseInt(hex.substring(0,2),16)/255;
    const g = parseInt(hex.substring(2,4),16)/255;
    const b = parseInt(hex.substring(4,6),16)/255;
    const max = Math.max(r,g,b), min = Math.min(r,g,b);
    let h=0, s=0, l=(max+min)/2;
    if(max !== min){
      const d = max-min;
      s = l > 0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h = ((g-b)/d + (g<b?6:0)); break;
        case g: h = ((b-r)/d + 2); break;
        case b: h = ((r-g)/d + 4); break;
      }
      h /= 6;
    }
    return {h: Math.round(h*360), s: Math.round(s*100), l: Math.round(l*100)};
  }

  // HSL to hex (h in [0..360], s/l in 0..100)
  function hslToHex(h,s,l){
    s /= 100; l /= 100;
    const k = n => (n + h/30) % 12;
    const a = s * Math.min(l, 1 - l);
    const f = n => {
      const color = l - a * Math.max(Math.min(k(n) - 3, 9 - k(n), 1), -1);
      return Math.round(255*color).toString(16).padStart(2,'0');
    };
    return `#${f(0)}${f(8)}${f(4)}`;
  }

  // Lighten/darken color by adjusting lightness (percentage)
  function adjustHexLightness(hex, deltaPercent){
    const hsl = hexToHSL(hex);
    let newL = Math.max(0, Math.min(100, hsl.l + deltaPercent));
    return hslToHex(hsl.h, hsl.s, newL);
  }

  // Format number with fixed decimals
  function fmt(v, d=2){ return Number.parseFloat(v).toFixed(d); }

  // Clamp
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  // Sleep / wait helper (returns a promise)
  function wait(ms){ return new Promise(res=>setTimeout(res,ms)); }

  // ----------------------------
  // Data: locations, blooms, NDVI
  // ----------------------------

  // Locations config (you can add more)
  const LOCATIONS = [
    { id: 'japan', label: 'Japan', lat: 36.2048, lng: 138.2529, species: 'Sakura (Cherry Blossom)', peakMonth: 3, baseColor: '#ffb6c1' },
    { id: 'alaska', label: 'Alaska', lat: 64.2008, lng: -149.4937, species: 'Lupine & Arctic Poppy', peakMonth: 6, baseColor: '#649ac8' },
    { id: 'madagascar', label: 'Madagascar', lat: -18.7669, lng: 46.8691, species: 'Baobab & Traveler\'s Palm', peakMonth: 9, baseColor: '#2e7d32' },
    { id: 'newzealand', label: 'New Zealand', lat: -40.9006, lng: 174.8860, species: 'Kōwhai & Pohutukawa', peakMonth: 10, baseColor: '#ffd700' },
    { id: 'fiji', label: 'Fiji', lat: -17.7134, lng: 178.0650, species: 'Hibiscus & Breadfruit', peakMonth: 5, baseColor: '#ff4500' }
  ];

  // We'll create many bloom points around each location for each month.
  let ALL_BLOOMS = []; // long list of points with fields (lat,lng,month,label,species,intensity,color,id)
  // generate synthetic bloom points per location & month
  (function generateBlooms(){
    ALL_BLOOMS = [];
    let uniqueId = 0;
    for(const loc of LOCATIONS){
      for(let month=0; month<12; month++){
        // compute an NDVI-like intensity for the month relative to peakMonth using a sinusoid
        // intensity range roughly 0..1, peaked at loc.peakMonth
        const phase = (month - loc.peakMonth) * (Math.PI / 6);
        // squared sine stands in for NDVI seasonal intensity shape
        const seasonal = Math.max(0, Math.sin(-phase)) ** 2; // 0..1
        // create a cluster of points for this location/month
        const pointsPerMonth = 20; // increase for denser clusters
        for(let i=0;i<pointsPerMonth;i++){
          const jitterLat = (Math.random() - 0.5) * 2.8; // degrees jitter
          const jitterLng = (Math.random() - 0.5) * 2.8;
          const intensity = clamp(seasonal + (Math.random() - 0.5) * 0.08, 0, 1);
          // color tweak by intensity: dark -> bright
          const color = adjustHexLightness(loc.baseColor, Math.round((intensity - 0.5) * 36));
          ALL_BLOOMS.push({
            id: `b${uniqueId++}`,
            lat: loc.lat + jitterLat,
            lng: loc.lng + jitterLng,
            month,
            locationId: loc.id,
            label: loc.label,
            species: loc.species,
            intensity,
            baseColor: loc.baseColor,
            color,
            // dynamic properties used for animation: __alt (altitude) and __rad (radius)
            __alt: 0.03 + intensity * 0.12,
            __rad: 0.25 + intensity * 0.65
          });
        }
      }
    }
  })();

  // NDVI timeseries simulated for each location (60 months historical + 12 forecast)
  const NDVI_SERIES = {}; // map locationId -> {dates:[], values:[], forecast:[]}
  (function generateNDVIs(){
    // We'll create 60 months of historical NDVI values (2018-01 .. 2022-12) with seasonal patterns
    const monthsCount = 60;
    const forecastMonths = 12;
    const startYear = 2018;
    for(const loc of LOCATIONS){
      const dates = [];
      const vals = [];
      const base = 0.45 + (Math.random()-0.5) * 0.12; // location baseline
      const amplitude = 0.18 + Math.random() * 0.12;
      for(let i=0;i<monthsCount;i++){
        const d = new Date(startYear, i, 1);
        let month = d.getMonth();
        // invert season for southern hemisphere (approx)
        let monthAdj = month;
        if(loc.id === 'newzealand') monthAdj = (month + 6) % 12;
        // seasonal value ~ base + amplitude * sin(2pi * month/12 - phase)
        const seasonal = amplitude * Math.sin((2*Math.PI*(monthAdj - loc.peakMonth))/12);
        const noise = (Math.random()-0.5) * 0.04;
        const val = clamp(base + seasonal + noise, 0, 1);
        dates.push(d);
        vals.push(val);
      }
      // simple forecast: last slope + seasonal pattern for next months
      const forecast = [];
      const lastVal = vals[vals.length-1];
      // compute linear slope from last 12 months
      let slope = 0;
      const last12 = vals.slice(-12);
      for(let i=0;i<last12.length-1;i++){
        slope += (last12[i+1] - last12[i]);
      }
      slope /= (last12.length-1);
      for(let i=1;i<=forecastMonths;i++){
        const futureMonth = (dates[dates.length-1].getMonth() + i) % 12;
        let monthAdj = futureMonth;
        if(loc.id === 'newzealand') monthAdj = (futureMonth + 6) % 12;
        const seasonal = amplitude * Math.sin((2*Math.PI*(monthAdj - loc.peakMonth))/12);
        const trend = slope * i;
        const pred = clamp(lastVal + trend + seasonal * 0.5, 0, 1); // smoother forecast
        forecast.push(pred);
      }
      NDVI_SERIES[loc.id] = { dates, values: vals, forecast };
    }
  })();

  // ----------------------------
  // Globe initialization
  // ----------------------------

  // The globe will render in black space; globeImageUrl(null) ensures no earth texture background
  const GlobeEl = document.getElementById('globeViz');

  // create globe instance
  const GlobeInstance = Globe()
    .globeImageUrl(null)                 // remove globe texture image -> black background space
    .backgroundColor('#000000')          // canvas background stays black
    .showAtmosphere(false)
    .showGraticules(true)
    // Use dynamic callback to read altitude and radius from each datum's __alt and __rad
    .pointAltitude(d => d.__alt || (0.03 + (d.intensity || 0) * 0.12))
    .pointRadius(d => d.__rad || (0.25 + (d.intensity || 0) * 0.65))
    .pointsTransitionDuration(180)       // smooth transitions when updating points dataset
    .pointColor(d => d.color || d.baseColor || '#ffffff')
    .pointLabel(d => {
      // Build the markup for the globe hover label (used by built-in tooltip fallback)
      const monthText = monthNames[(d.month ?? 0)];
      return `<div style="font-weight:700;color:${d.baseColor};">${d.label}</div>
              <div style="font-size:12px;color:#ddd;">${d.species}</div>
              <div style="font-size:12px;color:#bbb;margin-top:6px;">Peak: ${monthText} · Intensity ${fmt(d.intensity,2)}</div>`;
    })
    .onPointClick(d => {
      // When clicking a point, zoom to its cluster and update chart to that location
      if(!d) return;
      // find the location object and zoom there
      const loc = LOCATIONS.find(l => l.id === d.locationId);
      if(loc){
        // zoom to lat/lng with alt
        GlobeInstance.pointOfView({ lat: loc.lat, lng: loc.lng, altitude: 1.6 }, 1200);
        // update chart for that location
        updateChart(loc.id);
        // also set month to the point's month
        setMonth(d.month);
      }
    })
    .onPointHover(d => {
      // custom tooltip handling is implemented below; onPointHover is used to zap the hover data
      // we do nothing here because we'll use our custom raycast hover events to get screen position
    });

  // append globe to DOM
  GlobeInstance(GlobeEl);

  // small camera tweaks
  try {
    GlobeInstance.controls().enableZoom = true;
    GlobeInstance.controls().enablePan = false;
    GlobeInstance.camera().position.z = 400;
  } catch(e){
    // ignore if camera() not available
  }

  // ----------------------------
  // Tooltip & raycasting for better hover handling
  // ----------------------------

  const tooltip = document.getElementById('tooltip');

  // We'll use the Glove.gl's internal three.js scene and raycaster to implement a pixel-perfect tooltip
  const threeScene = GlobeInstance.scene();
  const threeCamera = GlobeInstance.camera();
  const threeRenderer = GlobeInstance.renderer();

  // Raycaster + mouse vector
  const raycaster = new THREE.Raycaster();
  const mouseVec = new THREE.Vector2();

  // Utility to show tooltip
  function showTooltip(x,y,html){
    tooltip.style.left = x + 'px';
    tooltip.style.top = y + 'px';
    tooltip.innerHTML = html;
    tooltip.style.display = 'block';
  }
  function hideTooltip(){
    tooltip.style.display = 'none';
  }

  // We'll translate screen coordinates to raycast point
  function onMouseMove(e){
    // convert to canvas coordinates relative to globe element
    const rect = GlobeEl.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    mouseVec.x = (cx / rect.width) * 2 - 1;
    mouseVec.y = - (cy / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouseVec, threeCamera);

    // globe.gl stores polygon/point meshes under internal property "pointsData" as meshes in scene
    // The meshes are in GlobeInstance.pointsMesh? but the public API for meshes is not stable;
    // We'll attempt to raycast against scene children and test userData of point meshes
    const intersects = raycaster.intersectObjects( threeScene.children, true );

    // find first intersected object that has userData && userData.datum (common in Globe.gl)
    let found = null;
    for(const i of intersects){
      if(i.object && i.object.userData && i.object.userData.datum){
        found = i.object.userData.datum;
        break;
      }
    }

    if(found){
      // show tooltip near pointer
      const label = `<div style="font-weight:700;color:${found.baseColor};">${found.label}</div>
                     <div style="font-size:12px;color:#ddd;">${found.species}</div>
                     <div style="font-size:12px;color:#bbb;margin-top:6px;">Peak: ${monthNames[found.month]} · Intensity: ${fmt(found.intensity,2)}</div>`;
      showTooltip(e.clientX, e.clientY, label);
    } else {
      hideTooltip();
    }
  }

  // Attach move listener to globe element for raycast hover
  GlobeEl.addEventListener('mousemove', onMouseMove);
  GlobeEl.addEventListener('mouseleave', hideTooltip);

  // ----------------------------
  // Month handling + animation (pulse)
  // ----------------------------

  let currentMonth = 0;
  let isPlaying = false;
  let playHandle = null;

  // Filter blooms for a month and update globe points dataset
  function setMonth(monthIndex){
    currentMonth = monthIndex;
    // update UI slider and label
    const slider = document.getElementById('monthSlider');
    if(slider) slider.value = String(monthIndex);
    const monthLabel = document.getElementById('monthLabel');
    if(monthLabel) monthLabel.textContent = monthNames[monthIndex];

    // pick blooms for that month
    const monthPoints = ALL_BLOOMS.filter(b => b.month === monthIndex);
    // refresh color intensity mapping: update color based on intensity
    for(const p of monthPoints){
      // color vary by intensity so the cluster is visually stronger when intensity high
      p.color = adjustHexLightness(p.baseColor, Math.round( (p.intensity - 0.5) * 40 ));
      // set base dynamic props
      p.__alt = 0.03 + p.intensity * 0.12;
      p.__rad = 0.25 + p.intensity * 0.65;
    }
    // set points dataset (Globe.gl will animatedly update positions/colors/size)
    GlobeInstance.pointsData(monthPoints);
  }

  // call setMonth initially
  setMonth(0);

  // Play/pause button wiring
  const playBtn = document.getElementById('playBtn');
  playBtn.addEventListener('click', ()=>{
    isPlaying = !isPlaying;
    playBtn.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
    playBtn.setAttribute('aria-pressed', String(isPlaying));
    if(isPlaying){
      playHandle = setInterval(()=>{
        const next = (currentMonth + 1) % 12;
        setMonth(next);
      }, 1100);
    } else {
      clearInterval(playHandle);
      playHandle = null;
    }
  });

  // slider wiring
  const sliderEl = document.getElementById('monthSlider');
  sliderEl.addEventListener('input', (e) => {
    const m = parseInt(e.target.value);
    setMonth(m);
  });

  // animate pulsing effect - runs every animation frame and nudges __alt & __rad
  (function frameAnimate(){
    requestAnimationFrame(frameAnimate);
    // get current points
    const points = GlobeInstance.pointsData();
    if(!points || !points.length) return;
    const t = Date.now() * 0.0025;
    // mutate in place to avoid reallocations
    for(let i=0;i<points.length;i++){
      const p = points[i];
      // pulse factor small oscillation -> result multiplier roughly 0.85 .. 1.15
      const phaseShift = (p.lat + p.lng) * 0.01 + i * 0.03;
      const pulse = 1 + 0.25 * Math.sin(t + phaseShift);
      // altitude + radius respond to intensity & pulse
      p.__alt = (0.03 + p.intensity * 0.14) * pulse;
      p.__rad = (0.22 + p.intensity * 0.66) * pulse;
    }
    // update dataset in place — Globe.gl will pick up modified __alt/__rad values if we call pointsData with same array
    GlobeInstance.pointsData(points);
  })();

  // ----------------------------
  // Chart: NDVI time series + forecast
  // ----------------------------

  const chartCtx = document.getElementById('ndviChart').getContext('2d');
  let ndviChart = null;
  let selectedChartIndex = null; // index of clicked data point in the chart

  function buildChart(locationId){
    // locationId corresponds to LOCATIONS[].id
    const series = NDVI_SERIES[locationId];
    if(!series) return;
    const histLabels = series.dates.map(d => d.toLocaleDateString('en-US',{month:'short', year:'numeric'}));
    const histValues = series.values.slice(); // length 60
    const forecast = series.forecast.slice(); // length 12
    // create combined labels/values for display (historical + forecast)
    const allLabels = histLabels.concat(forecast.map((_,i) => {
      const last = series.dates[series.dates.length-1];
      const dd = new Date(last.getFullYear(), last.getMonth() + i + 1, 1);
      return dd.toLocaleDateString('en-US',{month:'short', year:'numeric'});
    }));
    const allValues = histValues.concat(forecast);

    // destroy previous
    if(ndviChart) ndviChart.destroy();

    // gradient for fill
    const grad = chartCtx.createLinearGradient(0,0,0,200);
    grad.addColorStop(0, 'rgba(44,160,44,0.18)');
    grad.addColorStop(1, 'rgba(44,160,44,0.02)');

    ndviChart = new Chart(chartCtx, {
      type: 'line',
      data: {
        labels: allLabels,
        datasets: [
          {
            label: 'NDVI',
            data: allValues,
            borderColor: '#2ca02c',
            backgroundColor: grad,
            borderWidth: 2,
            pointRadius: function(ctx){
              // small points historically, slightly bigger in forecast end
              return (ctx.dataIndex >= histValues.length) ? 4 : 2;
            },
            pointHoverRadius: 6,
            tension: 0.33,
            fill: true
          },
          {
            label: 'Forecast (dashed)',
            data: allValues.map((v,i) => i < histValues.length ? null : v),
            borderColor: '#ff1493',
            borderDash: [6,6],
            borderWidth: 2,
            pointRadius: 3,
            tension: 0.33,
            fill: false
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 400 },
        plugins: {
          legend: { labels: { color: '#ddd' } },
          tooltip: {
            mode: 'index',
            intersect: false,
            callbacks: {
              label: function(ctx){
                return `NDVI: ${fmt(ctx.parsed.y,2)}`;
              }
            }
          }
        },
        scales: {
          x: { ticks: { color: '#bbb' } },
          y: { min: 0, max: 1, ticks: { color: '#bbb' } }
        },
        onClick: (e, elements) => {
          // click on chart: find nearest point & select month
          const points = ndviChart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, true);
          if(points.length){
            const idx = points[0].index;
            selectedChartIndex = idx;
            // update selected month (chart uses combined index; convert to month number)
            // find the date corresponding to idx in allLabels
            const dLabel = ndviChart.data.labels[idx];
            // parse month name from label to month index
            const m = new Date(dLabel).getMonth();
            setMonth(m);
            // update AI box selection text
            const aiText = document.getElementById('aiText');
            aiText.textContent = `Selected ${dLabel}. Click "Get AI Prediction" for a short interpretation.`;
          }
        }
      }
    });
  }

  // Build initial chart for first location
  buildChart(LOCATIONS[0].id);

  // Update chart wrapper when a country button is clicked
  function updateChart(locationId){
    buildChart(locationId);
    // also highlight cluster on globe: zoom
    const loc = LOCATIONS.find(l => l.id === locationId);
    if(loc){
      GlobeInstance.pointOfView({ lat: loc.lat, lng: loc.lng, altitude: 1.6 }, 1200);
    }
    // update AI box
    const aiText = document.getElementById('aiText');
    aiText.textContent = `Showing NDVI for ${loc.label}. Click a data point to pick a month.`;
  }

  // Hook up predict button: simple heuristic prediction explanation
  document.getElementById('predictBtn').addEventListener('click', ()=>{
    if(!ndviChart){
      document.getElementById('aiText').textContent = 'Chart not ready.';
      return;
    }
    if(selectedChartIndex === null){
      document.getElementById('aiText').textContent = 'Select a month on the chart first (click a point).';
      return;
    }
    // find label & value
    const label = ndviChart.data.labels[selectedChartIndex];
    const value = ndviChart.data.datasets[0].data[selectedChartIndex];
    // Simple interpretation: compare with recent seasonal mean & provide an explanation
    // look back up to 12 months window
    let recentVals = [];
    for(let i=Math.max(0, selectedChartIndex - 12); i<selectedChartIndex; i++){
      const v = ndviChart.data.datasets[0].data[i];
      if(typeof v === 'number') recentVals.push(v);
    }
    const recentMean = recentVals.length ? recentVals.reduce((a,b)=>a+b,0)/recentVals.length : value;
    const diff = value - recentMean;
    let trend = 'stable';
    if(diff > 0.03) trend = 'higher than recent months';
    else if(diff < -0.03) trend = 'lower than recent months';

    const aiHtml = `For <strong>${label}</strong> the NDVI is <strong>${fmt(value,2)}</strong> — this is ${trend}. 
      This prediction is based on seasonal patterns and short-term trend. If NDVI is rising, vegetation is greening or leaf cover is increasing; if falling, plants may be senescing or stressed.`;

    document.getElementById('aiText').innerHTML = aiHtml;
  });

  // ----------------------------
  // Country list UI wiring
  // ----------------------------
  const countryList = document.getElementById('countryList');
  LOCATIONS.forEach(loc => {
    const el = document.createElement('div');
    el.className = 'country-btn';
    el.title = `${loc.label} — ${loc.species}`;
    el.innerHTML = `
      <div style="display:flex; gap:8px; align-items:center;">
        <div style="width:12px;height:12px;background:${loc.baseColor};border-radius:3px;box-shadow:0 6px 18px ${loc.baseColor}33;"></div>
        <div style="font-weight:700;">${loc.label}</div>
      </div>
      <div style="font-size:12px; color:var(--muted);">Peak ${monthNames[loc.peakMonth]}</div>
    `;
    el.addEventListener('click', () => {
      // set month to peak; update chart and zoom
      setMonth(loc.peakMonth);
      updateChart(loc.id);
      // highlight cluster by briefly coloring them brighter
      highlightLocationCluster(loc.id);
    });
    countryList.appendChild(el);
  });

  // Highlight cluster function (temporary halo effect)
  function highlightLocationCluster(locationId){
    const currentPoints = GlobeInstance.pointsData() || [];
    // brighten baseColor of matching points
    for(const p of currentPoints){
      if(p.locationId === locationId){
        p.color = adjustHexLightness(p.baseColor, 26);
        // increase size slightly
        p.__rad = (p.__rad || 0.3) * 1.25;
      }
    }
    GlobeInstance.pointsData(currentPoints);

    // revert after short time
    setTimeout(()=>{
      const pts = GlobeInstance.pointsData() || [];
      for(const p of pts){
        if(p.locationId ===
      locationId){
        p.color = p.baseColor; // revert color
        p.__rad = 0.25 + p.intensity * 0.65; // revert size
      }
    }
    GlobeInstance.pointsData(pts);
  }, 1200); // revert after 1.2s
}

// ----------------------------
// Month names utility
// ----------------------------
const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];

// ----------------------------
// HDF file upload simulation
// ----------------------------
document.getElementById('hdfInput').addEventListener('change', (e)=>{
  const file = e.target.files[0];
  const msgEl = document.getElementById('uploadMsg');
  if(file){
    msgEl.textContent = `File "${file.name}" ready (simulated import)`;
    setTimeout(()=>{ msgEl.textContent = ''; }, 4000);
  }
});

// ----------------------------
// Initial setup
// ----------------------------
setMonth(0);
updateChart(LOCATIONS[0].id);

</script>
</body>
</html>
