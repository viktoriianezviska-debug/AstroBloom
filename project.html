<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AstroBloom Interactive Globe & Charts</title>
  <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIINfR7xP64jsImS44GdJqLsy7S+A8S53kU=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-200l2hLgL2N4m9D5s0qf0B8Z5D3k2p2s=" crossorigin=""></script>
  <script src="https://unpkg.com/three"></script>
  <script src="https://unpkg.com/globe.gl"></script>
  <style>
    body {
      font-family: 'Syne', sans-serif;
      background: black;
      color: #e5e7eb;
      margin: 0;
      overflow: hidden;
    }

    #container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    #charts-section {
      width: 30%;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      background-color: black;
      color: #f06292;
      /* Dark Rose Pink */
    }

    #globe-section {
      width: 70%;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #globeViz {
      width: 100%;
      height: 100vh;
    }

    #map {
      height: 300px;
      border-radius: 1rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease-in-out;
    }

    .chart-container {
      position: relative;
      height: 200px;
      margin-top: 1.5rem;
    }

    .chart-card {
      background-color: rgba(34, 34, 34, 0.7);
      /* Darker semi-transparent */
      border-radius: 1rem;
      padding: 1.5rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #country-buttons-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      /* Equal size buttons */
      gap: 5px;
    }

    #country-buttons-container button {
      font-family: 'Syne', sans-serif;
      padding: 8px 12px;
      border-radius: 20px;
      background-color: #333;
      color: #f06292;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
      box-sizing: border-box;
      width: 100%;
      /* Ensure equal width */
      text-align: center;
    }

    #country-buttons-container button:hover {
      background-color: #555;
    }

    #sliderContainer {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      color: white;
      font-size: 1.2em;
    }

    input[type="range"] {
      width: 60%;
    }

    #playBtn {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 1em;
      cursor: pointer;
      border-radius: 8px;
      border: none;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="charts-section">
      <h2 class="text-2xl font-bold text-white/90">Data Visualisation</h2>
      <div id="data-visualization-info" class="text-gray-400">
        <p>Click a marker on the map or a button below to see its NDVI trend and prediction.</p>
      </div>

      <div class="chart-card">
        <h3 class="text-lg font-semibold text-white/90 mb-2">NDVI Trend & Prediction</h3>
        <div id="chart-container-wrapper" class="chart-container flex justify-center items-center">
          <canvas id="ndviChart" class="hidden"></canvas>
          <div id="chart-status" class="text-gray-400">Loading chart...</div>
        </div>
      </div>

      <div id="ai-prediction-section" class="pt-6">
        <h3 class="text-2xl font-bold text-white/90">AI Prediction</h3>
        <div id="ai-response-container" class="bg-black text-gray-300 p-4 rounded-lg shadow-inner min-h-[5rem]">
          AI responses will appear here. Click a data point on the chart and then click "Get AI Prediction" for more
          info.
        </div>
        <div id="selected-month-info" class="mt-4 hidden">
          <span class="text-white font-medium">Selected Month: </span><span id="selected-month-text"
            class="text-blue-400"></span>
          <button id="get-prediction-button"
            class="ml-4 bg-blue-600 text-white py-1 px-3 rounded-full hover:bg-blue-700">Get AI Prediction</button>
        </div>
      </div>

      <div>
        <h3 class="text-xl font-semibold text-white/90 mb-4">Select a Country</h3>
        <div id="country-buttons-container">
        </div>
      </div>

      <div class="pt-6">
        <h3 class="text-2xl font-bold text-white/90">Upload Data</h3>
        <div class="flex flex-col space-y-2">
          <label for="hdf-file-input" class="block text-gray-400 font-medium">Upload a MODIS HDF file:</label>
          <input type="file" id="hdf-file-input" accept=".hdf"
            class="block w-full text-sm text-gray-500
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-full file:border-0
                        file:text-sm file:font-semibold
                        file:bg-violet-50 file:text-violet-700
                        hover:file:bg-violet-100
                    ">
          <p id="upload-status-message" class="text-sm text-gray-500 mt-2"></p>
        </div>
      </div>

      <div id="map" class="w-full"></div>
    </div>

    <div id="globe-section">
      <div id="globeViz"></div>
      <div id="sliderContainer">
        <span id="monthLabel">January</span><br>
        <input type="range" id="monthSlider" min="0" max="11" step="1" value="0"><br>
        <button id="playBtn">▶ Play</button>
      </div>
    </div>
  </div>

  <script>
    // --- Shared Constants ---
    const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September",
      "October", "November", "December"
    ];

    // --- Globe Visualization (NEW RING-BASED LOGIC) ---
    // Your provided bloom colors and multi-location data:
    const bloomColors = {
      Japan: ["#e8eb49", "#f5a2ac", "#f484d4", "#e647b9", "#ab8aec", "#d56de3", "#e898ec", "#f399f0", "#de4242",
        "#c27d37", "#e16473", "#f1ebb2"
      ],
      Alaska: ["#83b1dd", "#649ac8", "#a2d7ec", "#6a5acd", "#8f2da0", "#d25db9", "#cad239", "#d9eaa5", "#94dee1",
        "#5cabcaff", "#34879e", "#4b6cb1"
      ],
      Madagascar: ["#2e7d32", "#4b9d4f", "#6bc56f", "#e1a2d6", "#8be0dd", "#98d6e7", "#8ae5e5", "#9adbed", "#c71585",
        "#edb232", "#e2b330", "#b288d1"
      ],
      NewZealand: ["#ff1493", "#ff1493", "#ff8c00", "#b22222", "#b22222", "#778899", "#87ceeb", "#ffb6c1", "#ffff00",
        "#e3e54e", "#cb84c9", "#b52212"
      ],
      Fiji: ["#ebe41f", "#efa3ee", "#e28ee8", "#ef6cae", "#ea9cd4", "#da48c2", "#ffffff", "#ff4500", "#ea8ecb",
        "#edaa92", "#eea58b", "#e69a87"
      ]
    };
    const globeLocations = {
      Japan: [
        { lat: 35.6895, lng: 139.6917, label: "Tokyo" },
        { lat: 34.6937, lng: 135.5023, label: "Osaka" },
        { lat: 35.0116, lng: 135.7681, label: "Kyoto" },
        { lat: 43.06417, lng: 141.34694, label: "Sapporo" },
        { lat: 33.5902, lng: 130.4017, label: "Fukuoka" }
      ],
      Alaska: [
        { lat: 61.2181, lng: -149.9003, label: "Anchorage" },
        { lat: 64.8378, lng: -147.7164, label: "Fairbanks" },
        { lat: 58.3019, lng: -134.4197, label: "Juneau" },
        { lat: 64.5011, lng: -165.4064, label: "Nome" },
        { lat: 60.1042, lng: -149.4422, label: "Seward" }
      ],
      Madagascar: [
        { lat: -18.8792, lng: 47.5079, label: "Antananarivo" },
        { lat: -18.1494, lng: 49.4021, label: "Toamasina" },
        { lat: -15.7167, lng: 46.3167, label: "Mahajanga" },
        { lat: -23.3510, lng: 43.6667, label: "Toliara" },
        { lat: -12.2760, lng: 49.3110, label: "Antsiranana" }
      ],
      NewZealand: [
        { lat: -36.8485, lng: 174.7633, label: "Auckland" },
        { lat: -41.2865, lng: 174.7762, label: "Wellington" },
        { lat: -43.5321, lng: 172.6362, label: "Christchurch" },
        { lat: -45.8788, lng: 170.5028, label: "Dunedin" },
        { lat: -37.7832, lng: 175.2793, label: "Hamilton" }
      ],
      Fiji: [
        { lat: -18.1248, lng: 178.4501, label: "Suva" },
        { lat: -17.7768, lng: 177.4358, label: "Nadi" },
        { lat: -17.6160, lng: 177.4445, label: "Lautoka" },
        { lat: -18.8139, lng: 178.8458, label: "Levuka" },
        { lat: -16.4167, lng: 179.3833, label: "Labasa" }
      ]
    };

    const numRipples = 12;
    const basePeriod = 12000;

    function hexToRgb(hex) {
      const bigint = parseInt(hex.slice(1), 16);
      return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
    }

    const GlobeObj = Globe()
      .globeImageUrl('//unpkg.com/three-globe/example/img/earth-blue-marble.jpg')
      .pointsData([])
      .pointAltitude(0)
      .pointLabel(d => d.label)
      .pointColor(d => d.color)
      .pointRadius(0.18)
      .ringsData([])
      .ringMaxRadius(d => d.maxR)
      .ringPropagationSpeed(d => d.speed)
      .ringRepeatPeriod(d => d.period)
      .ringColor(d => t => `rgba(${d.colorRGB[0]},${d.colorRGB[1]},${d.colorRGB[2]},${1 - t})`);

    GlobeObj(document.getElementById('globeViz'));

    GlobeObj.controls().autoRotate = true;
    GlobeObj.controls().autoRotateSpeed = 0.3;

    function updateGlobeViz(monthIndex) {
      document.getElementById('monthLabel').textContent = monthNames[monthIndex];

      const rings = [];
      const points = [];

      for (const country of Object.keys(globeLocations)) {
        // Use the main country name for color lookup (Japan, Alaska, etc.)
        const colorHex = bloomColors[country] ? bloomColors[country][monthIndex] : "#ffffff";
        const colorRGB = hexToRgb(colorHex);

        for (const loc of globeLocations[country]) {
          points.push({
            lat: loc.lat,
            lng: loc.lng,
            label: `${country} — ${loc.label}`,
            color: colorHex
          });

          for (let i = 0; i < numRipples; i++) {
            rings.push({
              lat: loc.lat,
              lng: loc.lng,
              maxR: 3.5,
              speed: 2,
              period: basePeriod / (i + 1),
              colorRGB: colorRGB
            });
          }
        }
      }

      GlobeObj.pointsData(points);
      GlobeObj.ringsData(rings);
    }

    // --- Globe Animation/Controls (Adapted to use new updateGlobeViz) ---
    const slider = document.getElementById("monthSlider");
    const playBtn = document.getElementById("playBtn");
    let isPlaying = false;
    let playInterval;

    playBtn.addEventListener("click", () => {
      if (!isPlaying) {
        isPlaying = true;
        playBtn.textContent = "⏸ Pause";
        playInterval = setInterval(() => {
          let nextMonth = (parseInt(slider.value) + 1) % 12;
          slider.value = nextMonth;
          updateGlobeViz(nextMonth);
        }, 1000);
      } else {
        isPlaying = false;
        playBtn.textContent = "▶ Play";
        clearInterval(playInterval);
      }
    });

    slider.addEventListener("input", e => {
      updateGlobeViz(parseInt(e.target.value));
    });

    // small pulse for points (from the new globe code)
    (function pulsePoints() {
      const t = Date.now() * 0.002;
      GlobeObj.pointRadius(0.15 + Math.abs(Math.sin(t)) * 0.06);
      requestAnimationFrame(pulsePoints);
    })();


    // --- Charts and Data Analysis (ORIGINAL LOGIC) ---
    const locations = {
      "Japan": { "lat": 36.2048, "lon": 138.2529 },
      "Alaska": { "lat": 64.2008, "lon": -149.4937 },
      "Madagascar": { "lat": -18.7669, "lon": 46.8691 },
      "New Zealand": { "lat": -40.9006, "lon": 174.8860 },
      "Fiji": { "lat": -17.7134, "lon": 178.0650 }
    };

    let currentLocation = 'Japan';
    let myChart;
    let selectedDataPointIndex = null;

    function generateNDVIDataForLocation(locationName, startDate, numMonths) {
      const dates = [];
      const ndvi = [];
      const start = new Date(startDate);
      let seasonalFactor, baseValue;

      switch (locationName) {
        case "Japan":
          baseValue = 0.45;
          seasonalFactor = 0.25;
          break;
        case "Alaska":
          baseValue = 0.2;
          seasonalFactor = 0.6;
          break;
        case "Madagascar":
          baseValue = 0.7;
          seasonalFactor = 0.08;
          break;
        case "New Zealand":
          baseValue = 0.5;
          seasonalFactor = 0.2;
          break;
        case "Fiji":
          baseValue = 0.8;
          seasonalFactor = 0.05;
          break;
        default:
          baseValue = 0.5;
          seasonalFactor = 0.2;
      }

      for (let i = 0; i < numMonths; i++) {
        const date = new Date(start.getFullYear(), start.getMonth() + i, 1);
        dates.push(date);
        let month = date.getMonth();
        if (locationName === "New Zealand") {
          month = (month + 6) % 12;
        }
        const value = baseValue + seasonalFactor * Math.sin(month * (Math.PI / 6)) + 0.03 * (Math.random() - 0.5);
        ndvi.push(Math.max(0, Math.min(1, value)));
      }
      return { dates, ndvi };
    }

    let fetchedNDVIData = {};

    async function fetchDataAndLoad() {
      const ndviData = {};
      const numMonths = 60;
      for (const loc in locations) {
        ndviData[loc] = generateNDVIDataForLocation(loc, '2018-01-01', numMonths);
      }
      return ndviData;
    }

    function updateChart(locationName) {
      currentLocation = locationName;
      const chartData = fetchedNDVIData[locationName];
      if (!chartData) return;

      document.getElementById('ndviChart').classList.remove('hidden');
      document.getElementById('chart-status').style.display = 'none';

      const monthlyAverages = new Array(12).fill(0);
      const monthlyCounts = new Array(12).fill(0);
      chartData.dates.forEach((date, i) => {
        const month = date.getMonth();
        monthlyAverages[month] += chartData.ndvi[i];
        monthlyCounts[month]++;
      });
      const seasonalPattern = monthlyAverages.map((sum, month) => sum / monthlyCounts[month]);

      const xMonths = Array.from({
        length: chartData.dates.length
      }, (_, i) => i);
      let sumX = 0,
        sumY = 0,
        sumXY = 0,
        sumX2 = 0;
      const n = xMonths.length;
      for (let i = 0; i < n; i++) {
        sumX += xMonths[i];
        sumY += chartData.ndvi[i];
        sumXY += xMonths[i] * chartData.ndvi[i];
        sumX2 += xMonths[i] * xMonths[i];
      }
      const m = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);

      const futureDates = [];
      const predictedNDVI = [];
      const lastMonth = chartData.dates[chartData.dates.length - 1];
      for (let i = 1; i <= 12; i++) {
        const futureDate = new Date(lastMonth.getFullYear(), lastMonth.getMonth() + i, 1);
        const futureMonthIndex = futureDate.getMonth();
        const futureMonthTotalIndex = chartData.dates.length + i - 1;

        const prediction = seasonalPattern[futureMonthIndex] + (m * futureMonthTotalIndex);

        predictedNDVI.push(Math.max(0, Math.min(1, prediction)));
        futureDates.push(futureDate);
      }

      const allDates = chartData.dates.concat(futureDates);
      const allNDVI = chartData.ndvi.concat(predictedNDVI);
      const lastHistoricalIndex = chartData.dates.length - 1;

      const ctx = document.getElementById('ndviChart').getContext('2d');

      if (myChart) {
        myChart.destroy();
      }

      myChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: allDates.map(d => d.toLocaleString('default', {
            month: 'short',
            year: 'numeric'
          })),
          datasets: [{
              label: 'Historical NDVI',
              data: chartData.ndvi,
              borderColor: '#f06292',
              backgroundColor: 'rgba(240, 98, 146, 0.2)',
              pointBackgroundColor: '#f06292',
              borderWidth: 2,
              pointRadius: 3,
              fill: false,
              tension: 0.4
            },
            {
              label: 'Predicted NDVI',
              data: allNDVI,
              borderColor: '#ff4081',
              backgroundColor: 'rgba(255, 64, 129, 0.2)',
              pointBackgroundColor: '#ff4081',
              borderWidth: 2,
              pointRadius: 3,
              fill: false,
              borderDash: [5, 5],
              tension: 0.4,
              pointStyle: (context) => {
                const index = context.dataIndex;
                if (index <= lastHistoricalIndex) {
                  return 'circle';
                } else {
                  return 'star';
                }
              }
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: {
                display: true,
                text: 'Date',
                color: '#f06292'
              },
              ticks: {
                color: '#f06292',
                autoSkip: true,
                maxTicksLimit: 12
              },
              grid: {
                color: 'rgba(240, 98, 146, 0.1)'
              }
            },
            y: {
              title: {
                display: true,
                text: 'NDVI (Vegetation Index)',
                color: '#f06292'
              },
              min: 0,
              max: 1,
              ticks: {
                color: '#f06292'
              },
              grid: {
                color: 'rgba(240, 98, 146, 0.1)'
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: '#f06292'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(31, 41, 55, 0.8)',
              titleColor: '#f06292',
              bodyColor: '#f06292'
            }
          },
          onClick: handleChartClick
        }
      });

      const infoPanel = document.getElementById('data-visualization-info');
      infoPanel.innerHTML = `
                <h3 class="text-xl font-bold text-white/90 mb-2">${locationName}</h3>
                <p class="text-gray-400">Click on a data point to get an AI prediction for that month.</p>
            `;
      const selectedMonthInfo = document.getElementById('selected-month-info');
      selectedMonthInfo.classList.add('hidden');
    }

    function handleChartClick(event) {
      const points = myChart.getElementsAtEventForMode(event, 'nearest', {
        intersect: true
      }, true);
      if (points.length) {
        const firstPoint = points[0];
        const label = myChart.data.labels[firstPoint.index];
        const value = myChart.data.datasets[0].data[firstPoint.index];

        selectedDataPointIndex = firstPoint.index;
        const selectedMonthInfo = document.getElementById('selected-month-info');
        const selectedMonthText = document.getElementById('selected-month-text');
        selectedMonthText.textContent = label;
        selectedMonthInfo.classList.remove('hidden');
      }
    }

    function getPredictionForSelectedMonth() {
      if (selectedDataPointIndex === null) {
        document.getElementById('ai-response-container').textContent = "Please select a month on the chart first.";
        return;
      }

      const selectedMonth = myChart.data.labels[selectedDataPointIndex];
      const selectedValue = myChart.data.datasets[0].data[selectedDataPointIndex];
      const aiResponseContainer = document.getElementById('ai-response-container');

      aiResponseContainer.innerHTML =
        `<div class="loader mx-auto"></div> <span class="block text-center mt-2 text-gray-400">Thinking...</span>`;

      setTimeout(() => {
        const location = currentLocation;
        let response = "";

        if (myChart.data.datasets[1].data[selectedDataPointIndex] !== undefined && selectedDataPointIndex >= myChart.data.datasets[0].data.length) {
          // This is a future point (part of predicted NDVI)
          const predictedValue = myChart.data.datasets[1].data[selectedDataPointIndex];
          response = `For ${location}, the AI predicts a Normalized Difference Vegetation Index (NDVI) of approximately ${predictedValue.toFixed(2)} in ${selectedMonth}. This is a predicted value based on an analysis of past trends and seasonal cycles.`;
        } else {
          // This is a historical point
          response = `For ${selectedMonth} in ${location}, the historical NDVI value was approximately ${selectedValue.toFixed(2)}. This value is a historical measurement from our satellite data.`;
        }

        aiResponseContainer.innerHTML = response;
      }, 1500);
    }

    function initMap() {
      if (typeof L === 'undefined') {
        console.error("Leaflet.js not loaded. Map cannot be initialized.");
        return;
      }
      const map = L.map('map').setView([20, 0], 2);
      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
      }).addTo(map);

      for (const loc in locations) {
        const coords = locations[loc];
        const marker = L.marker([coords.lat, coords.lon]).addTo(map);
        marker.bindPopup(loc);
        marker.on('click', () => {
          updateChart(loc);
        });
      }
    }

    function createCountryButtons() {
      const buttonContainer = document.getElementById('country-buttons-container');
      const locationsArray = Object.keys(locations);

      locationsArray.forEach(loc => {
        const button = document.createElement('button');
        button.textContent = loc;
        button.style.fontFamily = 'Syne';
        button.addEventListener('click', () => {
          updateChart(loc);
          flyToLocation(loc);
        });
        buttonContainer.appendChild(button);
      });
    }

    // Function to fly to location on the Globe (Uses coordinates from the chart locations for consistency)
    function flyToLocation(locationName) {
      const location = locations[locationName];
      if (location) {
        GlobeObj.pointOfView({
          lat: location.lat,
          lng: location.lon,
          altitude: 2
        }, 1500);
      }
    }

    window.onload = async () => {
      const chartStatus = document.getElementById('chart-status');
      const hdfFileInput = document.getElementById('hdf-file-input');
      const uploadStatusMessage = document.getElementById('upload-status-message');
      const getPredictionButton = document.getElementById('get-prediction-button');

      if (typeof Chart === 'undefined') {
        chartStatus.innerHTML = "Error: Chart.js failed to load. Please try again.";
        return;
      }

      try {
        chartStatus.textContent = "Fetching data...";
        fetchedNDVIData = await fetchDataAndLoad();
        chartStatus.textContent = "Data loaded.";
      } catch (error) {
        chartStatus.textContent = "Failed to load data. Please check the console for errors.";
        console.error("Initialization error:", error);
      }

      initMap();
      createCountryButtons();
      updateChart('Japan');

      // --- Initializing Globe: Uses the new logic ---
      updateGlobeViz(0);
      flyToLocation('Japan');

      if (getPredictionButton) {
        getPredictionButton.addEventListener('click', getPredictionForSelectedMonth);
      }

      hdfFileInput.addEventListener('change', (event) => {
        if (event.target.files.length > 0) {
          uploadStatusMessage.className = 'text-sm text-yellow-400 mt-2';
          uploadStatusMessage.textContent = 'Processing file...';

          setTimeout(() => {
            uploadStatusMessage.className = 'text-sm text-green-400 mt-2';
            uploadStatusMessage.textContent =
              'File uploaded successfully. Simulating data visualization. Please select a location to see the updated chart.';
            updateChart(currentLocation);
          }, 2000);
        }
      });
    };
  </script>
</body>

</html>
